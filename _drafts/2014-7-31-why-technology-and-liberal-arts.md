---
layout: post
title: Why Technology and Liberal Arts?
tags: Meta
---

Through secondary school I loved all of the subjects. But inevitably, there
were days where homework was not what I felt like doing. On these days, I found
myself using homework from one subject to avoid the homework from another. Math
would trump Spanish, and Spanish would pummel English. While eventually it all
was all complete, I enjoyed watching as my interests became apparent in my
decisions.
<!-- more -->

Despite avoiding my English homework, I really did enjoy the class. I loved
reading books like *The Kite Runner*, *Reservation Blues*, and *We*. Speaking
of which, if you haven't read *We* by Yevgeny Zamyatin, I highly recommend it.
It's a dystopian future novel commenting on the Russian revolutions of the
early twentieth century (*We* predated *1984*, *Brave New World*, more well
known books in the genre).

I feel fortunate to have enjoyed my classes and my schooling in general. And
beyond just school, I am most grateful that I love **learning**.

When it was time for me to start deciding what my academic focus would be in
college, I knew the most important factor would be that the subject would
continue to evolve and generate more information for me to learn.

**Always be learning**.

Ideally, work would mix constrained and unconstrained problems,
forcing me to think creatively both in a small problem space and when
confronted with a blank canvas. So I found computer science and economics.

Found isn't the right word; these were the two fields that I spent the most
time outside of school learning about. They also shaped some of the electives I
took, Introduction to Programming and Introduction to Computer Science, and
what I would focus on when I had more flexible homework assignments.

Learning is at the heart of computer science and economics. As the fields grow,
researchers discover more applications of their work affecting many other
fields. For me, I find both of these fields the most interesting when they are
applied to other research areas - but especially so when applied to each other.

This past January, I read a collection of essays on open source software
development entitled [*The Cathedral and the
Bazaar*](http://www.catb.org/esr/writings/cathedral-bazaar/) by Eric S. Raymond
(ESR). Named after the essay of the same name, his essays contrast two models
of software development: proprietary (cathedral) and open source (bazaar). In
many of his essays, ESR dives into the economics of software. Software is
fundamentally different than most other products sold on the market. Software
can have a high development cost, but will cost close to nothing to reproduce.
Some software is even incredibly cheap to develop. Think of the number of
weekend projects that make it into the App Store, [which Apple is cracking down
on](https://developer.apple.com/appstore/resources/approval/guidelines.html).

Economics is all about making decisions while facing constraints. Money, time,
memory, clock cycles, economic growth, latency, storage costs - don't forget
about gravity! Economic modeling starts with generating realistic constraints
that ultimately determine the accuracy of your predictions.

Economics and computer science are not actually that different from each other.

The best thing about both of these fields is that they change the way you
think. Tyler Cowen explains in *An Economist Gets Lunch* why food quality in
the US decreased during prohibition and why great barbecue restaurants also
serve excellent breakfasts. In *The UNIX Philosophy*, Mike Gancarz draws upon
Ken Thompson and others to distill [nine essential key
points](http://en.wikipedia.org/wiki/Unix_philosophy#Mike_Gancarz:_The_UNIX_Philosophy)
for adherents to the Unix philosophy.

> 1. Small is beautiful.
> 2. Make each program do one thing well.
> 3. Build a prototype as soon as possible.
> 4. Choose portability over efficiency.
> 5. Store data in flat text files.
> 6. Use software leverage to your advantage.
> 7. Use shell scripts to increase leverage and portability.
> 8. Avoid captive user interfaces.
> 9. Make every program a filter.

Each of these precepts influences the way I approach problems, both in software
development and in my day-to-day life.

This is the power of economics and computer science: both affect the way I
think about and approach problems.

To close, here are three key points from the [How To Become a
Hacker](http://www.catb.org/esr/faqs/hacker-howto.html) appendix to ESR's
*Cathedral*. I argue that these ideas are ingrained in economists and computer
scientists alike. They are also what excite me most about my future in both of
these fields.

> - The World Is Full of Fascinating Problems Waiting To Be Solved
> - Nobody Should Ever Have To Solve A Problem Twice
> - Boredom And Drudgery Are Evil

*Always be learning.*
